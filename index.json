[{"content":" Visit about:config Search and enable toolkit.legacyUserProfileCustomizations.stylesheets Visit about:support Click on Open Directory which is to the right of Profile Directory Create a new folder called chrome Open chrome and create a new file named userChome.css Paste the following #tabbrowser-tabs { visibility: collapse; } #titlebar #TabsToolbar { background-color: var(--toolbar-bgcolor); background-image: var(--toolbar-bgimage); padding-top: 5px; } Tested on Firefox v100.0.2.\n","permalink":"https://darve.sh/posts/setup/firefox-hide-native-tabs/","summary":"Visit about:config Search and enable toolkit.legacyUserProfileCustomizations.stylesheets Visit about:support Click on Open Directory which is to the right of Profile Directory Create a new folder called chrome Open chrome and create a new file named userChome.css Paste the following #tabbrowser-tabs { visibility: collapse; } #titlebar #TabsToolbar { background-color: var(--toolbar-bgcolor); background-image: var(--toolbar-bgimage); padding-top: 5px; } Tested on Firefox v100.0.2.","title":"Hide Native Tabs in Firefox"},{"content":"Generate key ssh-keygen -t ed25519 Write config Create a file named config inside ~/.ssh and add the following. Host \u0026lt;server-name\u0026gt; Hostname \u0026lt;ip\u0026gt; User \u0026lt;username\u0026gt; IdentityFile \u0026lt;path-to-private-key\u0026gt;\nNow you can log in to your server easily with ssh \u0026lt;server-name\u0026gt; instead of having to type ssh -i \u0026lt;path-to-private-key\u0026gt; \u0026lt;username\u0026gt;@\u0026lt;Hostname\u0026gt;\nFix disconnection on idle Client will keep sending null packets every 100 seconds to keep the connection alive. Add ServerAliveInterval 100\nto either\nsudo vi /etc/ssh/ssh_config or\nvi ~/.ssh/config Alternatively, you can do ssh -o ServerAliveInterval=100 me@remote\nReverse Port Forwading Add these lines to /etc/ssh/sshd_config on your server\nGatewayPorts clientspecified AllowTcpForwarding yes Then open the terminal on your local computer, paste the following and change the values suitably\nssh -o ExitOnForwardFailure=yes -v -N -R \u0026#34;*:$SERVER_PORT:*:$CLIENT_PORT\u0026#34; server_name Flags:\nR = Specifies that connections to the given TCP port or Unix socket on the remote (server) host are to be forwarded to the local side.\nN\t= Do not execute a remote command, in simple words, do not log in to the server.\nv = Verbose mode. Causes ssh to print debugging messages about its progress.\nserver_name is either username@ip or server name that you configured on your ~/.ssh/config\nIf you want to bind to only IPv4 addresses, use 0.0.0.0 instead of *\nIf there is frequent disconnection, follow this to fix it.\n","permalink":"https://darve.sh/posts/setup/setup-ssh/","summary":"Generate key ssh-keygen -t ed25519 Write config Create a file named config inside ~/.ssh and add the following. Host \u0026lt;server-name\u0026gt; Hostname \u0026lt;ip\u0026gt; User \u0026lt;username\u0026gt; IdentityFile \u0026lt;path-to-private-key\u0026gt;\nNow you can log in to your server easily with ssh \u0026lt;server-name\u0026gt; instead of having to type ssh -i \u0026lt;path-to-private-key\u0026gt; \u0026lt;username\u0026gt;@\u0026lt;Hostname\u0026gt;\nFix disconnection on idle Client will keep sending null packets every 100 seconds to keep the connection alive. Add ServerAliveInterval 100\nto either","title":"Setup SSH"},{"content":"Hardware Laptop: Lenovo Legion 5 Pro (AMD Ryzen 7 5800H, 32GB RAM, NVIDIA RTX 3060)\nKeyboard: Redgear Manta MT21\nMouse: Razer DeathAdder V2 Mini\nMonitor: Lenovo Q24i-10\nSoftware OS: Windows 10 with Debian(WSL2) for Development\nEditor: VSCode, vim\nTerminal: Windows Terminal\nShell: zsh\nVSCode Theme: Ayu Dark Bordered\nFont: Cascadia Code\nBrowser: Firefox\nMusic: Spotify\n","permalink":"https://darve.sh/tools/","summary":"Hardware Laptop: Lenovo Legion 5 Pro (AMD Ryzen 7 5800H, 32GB RAM, NVIDIA RTX 3060)\nKeyboard: Redgear Manta MT21\nMouse: Razer DeathAdder V2 Mini\nMonitor: Lenovo Q24i-10\nSoftware OS: Windows 10 with Debian(WSL2) for Development\nEditor: VSCode, vim\nTerminal: Windows Terminal\nShell: zsh\nVSCode Theme: Ayu Dark Bordered\nFont: Cascadia Code\nBrowser: Firefox\nMusic: Spotify","title":"What I use"},{"content":"Rules If a module named human has no submodules, you should put the declaration for the human in a file named human.rs If a module named human does have a submodule, you should put the declarations for human in a file named human/mod.rs Example\n/* src/lib.rs */ pub mod Human; /* src/human/mod.rs */ pub mod social; pub mod action; /* src/human/social.rs */ pub fn have_fun(){ println!(\u0026#34;Have fun\u0026#34;); } /* src/human/action.rs */ pub fn walk(){ println!(\u0026#34;walking\u0026#34;); } /* src/main.rs */ use my_project_name::human; fn main(){ human::social::have_fun(); human::action::walk(); } ","permalink":"https://darve.sh/posts/rust/modules/","summary":"Rules If a module named human has no submodules, you should put the declaration for the human in a file named human.rs If a module named human does have a submodule, you should put the declarations for human in a file named human/mod.rs Example\n/* src/lib.rs */ pub mod Human; /* src/human/mod.rs */ pub mod social; pub mod action; /* src/human/social.rs */ pub fn have_fun(){ println!(\u0026#34;Have fun\u0026#34;); } /* src/human/action.rs */ pub fn walk(){ println!","title":"Rust: Modules"},{"content":"let greeting = \u0026#34;Good morning\u0026#34;; greeting is a string literal and they are immutable. The reason why it\u0026rsquo;s immutable is explained below.\nIn Rust, you can store part of the String and they are called String slices. For example,\nlet str = String::from(\u0026#34;Hello there\u0026#34;); let hello = \u0026amp;str[0..4]; let there = \u0026amp;str[6..10]; hello and there are String slices. They store references to the portion of the String.\nNow let\u0026rsquo;s talk about why string literals are immutable. The string literals are literally slices of a string. Imagine that the value Good morning is stored on the heap(in a memory location called temp) then the greeting variable is basically temp[0..temp.len()] (can write as temp[..])\nAs I mentioned in the ownership chapter, if you have an immutable reference to a variable, you cannot take a mutable reference for the same.\nHere is an example.\nfn main(){ let str = String::from(\u0026#34;Hello there\u0026#34;); let hello = \u0026amp;str[0..4]; let there = \u0026amp;str[6..10]; /*this will result in an error because `hello` a `there` already have an immutable reference to `str`*/ str.clear(); } ","permalink":"https://darve.sh/posts/rust/string-literals-and-slices/","summary":"let greeting = \u0026#34;Good morning\u0026#34;; greeting is a string literal and they are immutable. The reason why it\u0026rsquo;s immutable is explained below.\nIn Rust, you can store part of the String and they are called String slices. For example,\nlet str = String::from(\u0026#34;Hello there\u0026#34;); let hello = \u0026amp;str[0..4]; let there = \u0026amp;str[6..10]; hello and there are String slices. They store references to the portion of the String.\nNow let\u0026rsquo;s talk about why string literals are immutable.","title":"Rust: String Literals and Slices"},{"content":"The #[cfg(test)] annotation tells Rust to run the function only when cargo test is run and not when cargo build is run\nFunctions assert!(1 == 2, \u0026#34;wasn\u0026#39;t true\u0026#34;); //it will print wasn\u0026#39;t true when test fails assert_eq!(6, 6); assert_ne!(6, 5); Run test cargo test Run tests in parallel or consecutively cargo test -- --test-threads=\u0026lt;numbers\u0026gt; Change output capture behavior, show logs cargo test -- --nocapture Run single or multiple tests cargo test \u0026lt;function-name|pattern\u0026gt; pub fn add_one(num: i64) -\u0026gt; i64 { num + 1 } pub fn add_two(num: i64) -\u0026gt; i64 { num + 2 } #[cfg(test)] mod tests { use super::*; #[test] fn add_one_test() { assert_eq!!(4, add_one(3)); } #[test] fn add_two_test() { assert_eq!(6, add_two(4)); } } Example\n//will run only one test cargo test add_one_test //will run all tests starting with add_ cargo test add_ Test function that should panic use #[should_panic] attribute\npub fn i_panic() { panic!(\u0026#34;omg!\u0026#34;); } #[cfg(test)] mod test { use super::*; #[test] #[should_panic] fn should_panic() { i_panic(); } } //The above test will pass Ignore a test Use #[ignore] attribute\nIntegration tests Make a directory called tests at the root level of the project. Assume you have this code in the lib.rs file in the project adder\n/* |-adder/src |--lib.rs */ pub add_two(num: i64) -\u0026gt; i64{ num + 2 } tests/integration_test.rs\nextern crate adder; #[test] fn add_two_test(){ assert_eq!(6, adder::add_two(4)); } We don\u0026rsquo;t need to use #[cfg(test)] here. When running cargo test, it will run both unit and integration tests. You can also run only tests from a particular integration test file. In the above example, if you want to run tests from integration_test.ts file\ncargo test --test integration_test.rs ","permalink":"https://darve.sh/posts/rust/tests/","summary":"The #[cfg(test)] annotation tells Rust to run the function only when cargo test is run and not when cargo build is run\nFunctions assert!(1 == 2, \u0026#34;wasn\u0026#39;t true\u0026#34;); //it will print wasn\u0026#39;t true when test fails assert_eq!(6, 6); assert_ne!(6, 5); Run test cargo test Run tests in parallel or consecutively cargo test -- --test-threads=\u0026lt;numbers\u0026gt; Change output capture behavior, show logs cargo test -- --nocapture Run single or multiple tests cargo test \u0026lt;function-name|pattern\u0026gt; pub fn add_one(num: i64) -\u0026gt; i64 { num + 1 } pub fn add_two(num: i64) -\u0026gt; i64 { num + 2 } #[cfg(test)] mod tests { use super::*; #[test] fn add_one_test() { assert_eq!","title":"Rust: Writing tests"}]