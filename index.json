[{"content":"Rules  If a module named human has no submodules, you should put the declaration for the human in a file named human.rs If a module named human does have a submodule, you should put the declarations for human in a file named human/mod.rs  Example\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  /* src/lib.rs */pubmod Human;/* src/human/mod.rs */pubmod social;pubmod action;/* src/human/social.rs */pubfn have_fun(){println!(\u0026#34;Have fun\u0026#34;);}/* src/human/action.rs */pubfn walk(){println!(\u0026#34;walking\u0026#34;);}/* src/main.rs */usemy_project_name::human;fn main(){human::social::have_fun();human::action::walk();}  ","permalink":"https://darve.sh/posts/rust/modules/","summary":"Rules  If a module named human has no submodules, you should put the declaration for the human in a file named human.rs If a module named human does have a submodule, you should put the declarations for human in a file named human/mod.rs  Example\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  /* src/lib.","title":"Rust: Modules"},{"content":"1  letgreeting=\u0026#34;Good morning\u0026#34;;  greeting is a string literal and they are immutable. The reason why it\u0026rsquo;s immutable is explained below.\nIn Rust, you can store part of the String and they are called String slices. For example,\n1 2 3 4  letstr=String::from(\u0026#34;Hello there\u0026#34;);lethello=\u0026amp;str[0..4];letthere=\u0026amp;str[6..10];  hello and there are String slices. They store references to the portion of the String.\nNow let\u0026rsquo;s talk about why string literals are immutable. The string literals are literally slices of a string. Imagine that the value Good morning is stored on the heap(in a memory location called temp) then the greeting variable is basically temp[0..temp.len()] (can write as temp[..])\nAs I mentioned in the ownership chapter, if you have an immutable reference to a variable, you cannot take a mutable reference for the same.\nHere is an example.\n1 2 3 4 5 6 7 8 9 10  fn main(){letstr=String::from(\u0026#34;Hello there\u0026#34;);lethello=\u0026amp;str[0..4];letthere=\u0026amp;str[6..10];/*this will result in an error because `hello` a `there` already have an immutable reference to `str`*/str.clear();}  ","permalink":"https://darve.sh/posts/rust/string-literals-and-slices/","summary":"1  letgreeting=\u0026#34;Good morning\u0026#34;;  greeting is a string literal and they are immutable. The reason why it\u0026rsquo;s immutable is explained below.\nIn Rust, you can store part of the String and they are called String slices. For example,\n1 2 3 4  letstr=String::from(\u0026#34;Hello there\u0026#34;);lethello=\u0026amp;str[0..4];letthere=\u0026amp;str[6..10];  hello and there are String slices. They store references to the portion of the String.\nNow let\u0026rsquo;s talk about why string literals are immutable.","title":"Rust: String Literals and Slices"},{"content":"The #[cfg(test)] annotation tells Rust to run the function only when cargo test is run and not when cargo build is run\nFunctions 1 2 3 4  assert!(1==2,\u0026#34;wasn\u0026#39;t true\u0026#34;);//it will print wasn\u0026#39;t true when test fails assert_eq!(6,6);assert_ne!(6,5);  Run test 1  cargo test   Run tests in parallel or consecutively 1  cargo test -- --test-threads=\u0026lt;numbers\u0026gt;   Change output capture behavior, show logs 1  cargo test -- --nocapture   Run single or multiple tests 1  cargo test \u0026lt;function-name|pattern\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  pubfn add_one(num: i64)-\u0026gt; i64 {num+1}pubfn add_two(num: i64)-\u0026gt; i64 {num+2}#[cfg(test)]mod tests{usesuper::*;#[test]fn add_one_test(){assert_eq!!(4,add_one(3));}#[test]fn add_two_test(){assert_eq!(6,add_two(4));}}  Example\n1 2 3 4  //will run only one test cargo test add_one_test //will run all tests starting with add_ cargo test add_   Test function that should panic use #[should_panic] attribute\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  pubfn i_panic(){panic!(\u0026#34;omg!\u0026#34;);}#[cfg(test)]mod test{usesuper::*;#[test]#[should_panic]fn should_panic(){i_panic();}}//The above test will pass   Ignore a test Use #[ignore] attribute\nIntegration tests Make a directory called tests at the root level of the project. Assume you have this code in the lib.rs file in the project adder\n1 2 3 4 5 6 7  /* |-adder/src |--lib.rs */pubadd_two(num: i64)-\u0026gt; i64{num+2}  tests/integration_test.rs\n1 2 3 4 5 6 7  externcrateadder;#[test]fn add_two_test(){assert_eq!(6,adder::add_two(4));}  We don\u0026rsquo;t need to use #[cfg(test)] here. When running cargo test, it will run both unit and integration tests. You can also run only tests from a particular integration test file. In the above example, if you want to run tests from integration_test.ts file\n1  cargotest--testintegration_test.rs  ","permalink":"https://darve.sh/posts/rust/tests/","summary":"The #[cfg(test)] annotation tells Rust to run the function only when cargo test is run and not when cargo build is run\nFunctions 1 2 3 4  assert!(1==2,\u0026#34;wasn\u0026#39;t true\u0026#34;);//it will print wasn\u0026#39;t true when test fails assert_eq!(6,6);assert_ne!(6,5);  Run test 1  cargo test   Run tests in parallel or consecutively 1  cargo test -- --test-threads=\u0026lt;numbers\u0026gt;   Change output capture behavior, show logs 1  cargo test -- --nocapture   Run single or multiple tests 1  cargo test \u0026lt;function-name|pattern\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  pubfn add_one(num: i64)-\u0026gt; i64 {num+1}pubfn add_two(num: i64)-\u0026gt; i64 {num+2}#[cfg(test)]mod tests{usesuper::*;#[test]fn add_one_test(){assert_eq!","title":"Rust: Writing tests"},{"content":"Work in progress\n","permalink":"https://darve.sh/posts/tools-of-the-trade/","summary":"Work in progress","title":"What I use"}]