[{"content":" Visit about:config Search and enable toolkit.legacyUserProfileCustomizations.stylesheets Visit about:support Click on Open Directory which is to the right of Profile Directory Create a new folder called chrome Open chrome and create a new file named userChome.css Paste the following  1 2 3 4 5 6 7 8 9  #tabbrowser-tabs { visibility: collapse; } #titlebar #TabsToolbar { background-color: var(--toolbar-bgcolor); background-image: var(--toolbar-bgimage); padding-top: 5px; }   Tested on Firefox v100.0.2.\n","permalink":"https://darve.sh/posts/setup/firefox-hide-native-tabs/","summary":"Visit about:config Search and enable toolkit.legacyUserProfileCustomizations.stylesheets Visit about:support Click on Open Directory which is to the right of Profile Directory Create a new folder called chrome Open chrome and create a new file named userChome.css Paste the following  1 2 3 4 5 6 7 8 9  #tabbrowser-tabs { visibility: collapse; } #titlebar #TabsToolbar { background-color: var(--toolbar-bgcolor); background-image: var(--toolbar-bgimage); padding-top: 5px; }   Tested on Firefox v100.","title":"Hide Native Tabs in Firefox"},{"content":"Generate key ssh-keygen -t ed25519 Write config Create a file named config inside ~/.ssh and add the following. Host \u0026lt;server-name\u0026gt; Hostname \u0026lt;ip\u0026gt; User \u0026lt;username\u0026gt; IdentityFile \u0026lt;path-to-private-key\u0026gt;\nNow you can log in to your server easily with ssh \u0026lt;server-name\u0026gt; instead of having to type ssh -i \u0026lt;path-to-private-key\u0026gt; \u0026lt;username\u0026gt;@\u0026lt;Hostname\u0026gt;\nFix disconnection on idle Client will keep sending null packets every 100 seconds to keep the connection alive. Add ServerAliveInterval 100\nto either sudo vi /etc/ssh/ssh_config or vi ~/.ssh/config Alternatively, you can do ssh -o ServerAliveInterval=100 me@remote\n","permalink":"https://darve.sh/posts/setup/setup-ssh/","summary":"Generate key ssh-keygen -t ed25519 Write config Create a file named config inside ~/.ssh and add the following. Host \u0026lt;server-name\u0026gt; Hostname \u0026lt;ip\u0026gt; User \u0026lt;username\u0026gt; IdentityFile \u0026lt;path-to-private-key\u0026gt;\nNow you can log in to your server easily with ssh \u0026lt;server-name\u0026gt; instead of having to type ssh -i \u0026lt;path-to-private-key\u0026gt; \u0026lt;username\u0026gt;@\u0026lt;Hostname\u0026gt;\nFix disconnection on idle Client will keep sending null packets every 100 seconds to keep the connection alive. Add ServerAliveInterval 100\nto either sudo vi /etc/ssh/ssh_config or vi ~/.","title":"Setup SSH"},{"content":"Hardware Laptop: Lenovo Legion 5 Pro (AMD Ryzen 7 5800H, 32GB RAM, NVIDIA RTX 3060)\nKeyboard: Redgear Manta MT21\nMouse: Razer DeathAdder V2 Mini\nMonitor: Lenovo Q24i-10\nSoftware OS: Windows 10 with Debian(WSL2) for Development\nEditor: VSCode, vim\nTerminal: Windows Terminal\nShell: zsh\nVSCode Theme: Ayu Dark Bordered\nFont: Cascadia Code\nBrowser: Firefox\nMusic: Spotify\n","permalink":"https://darve.sh/tools/","summary":"Hardware Laptop: Lenovo Legion 5 Pro (AMD Ryzen 7 5800H, 32GB RAM, NVIDIA RTX 3060)\nKeyboard: Redgear Manta MT21\nMouse: Razer DeathAdder V2 Mini\nMonitor: Lenovo Q24i-10\nSoftware OS: Windows 10 with Debian(WSL2) for Development\nEditor: VSCode, vim\nTerminal: Windows Terminal\nShell: zsh\nVSCode Theme: Ayu Dark Bordered\nFont: Cascadia Code\nBrowser: Firefox\nMusic: Spotify","title":"What I use"},{"content":"Rules  If a module named human has no submodules, you should put the declaration for the human in a file named human.rs If a module named human does have a submodule, you should put the declarations for human in a file named human/mod.rs  Example\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  /* src/lib.rs */pubmod Human;/* src/human/mod.rs */pubmod social;pubmod action;/* src/human/social.rs */pubfn have_fun(){println!(\u0026#34;Have fun\u0026#34;);}/* src/human/action.rs */pubfn walk(){println!(\u0026#34;walking\u0026#34;);}/* src/main.rs */usemy_project_name::human;fn main(){human::social::have_fun();human::action::walk();}  ","permalink":"https://darve.sh/posts/rust/modules/","summary":"Rules  If a module named human has no submodules, you should put the declaration for the human in a file named human.rs If a module named human does have a submodule, you should put the declarations for human in a file named human/mod.rs  Example\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  /* src/lib.","title":"Rust: Modules"},{"content":"1  letgreeting=\u0026#34;Good morning\u0026#34;;  greeting is a string literal and they are immutable. The reason why it\u0026rsquo;s immutable is explained below.\nIn Rust, you can store part of the String and they are called String slices. For example,\n1 2 3 4  letstr=String::from(\u0026#34;Hello there\u0026#34;);lethello=\u0026amp;str[0..4];letthere=\u0026amp;str[6..10];  hello and there are String slices. They store references to the portion of the String.\nNow let\u0026rsquo;s talk about why string literals are immutable. The string literals are literally slices of a string. Imagine that the value Good morning is stored on the heap(in a memory location called temp) then the greeting variable is basically temp[0..temp.len()] (can write as temp[..])\nAs I mentioned in the ownership chapter, if you have an immutable reference to a variable, you cannot take a mutable reference for the same.\nHere is an example.\n1 2 3 4 5 6 7 8 9  fn main(){letstr=String::from(\u0026#34;Hello there\u0026#34;);lethello=\u0026amp;str[0..4];letthere=\u0026amp;str[6..10];/*this will result in an error because `hello` a `there` already have an immutable reference to `str`*/str.clear();}  ","permalink":"https://darve.sh/posts/rust/string-literals-and-slices/","summary":"1  letgreeting=\u0026#34;Good morning\u0026#34;;  greeting is a string literal and they are immutable. The reason why it\u0026rsquo;s immutable is explained below.\nIn Rust, you can store part of the String and they are called String slices. For example,\n1 2 3 4  letstr=String::from(\u0026#34;Hello there\u0026#34;);lethello=\u0026amp;str[0..4];letthere=\u0026amp;str[6..10];  hello and there are String slices. They store references to the portion of the String.\nNow let\u0026rsquo;s talk about why string literals are immutable.","title":"Rust: String Literals and Slices"},{"content":"The #[cfg(test)] annotation tells Rust to run the function only when cargo test is run and not when cargo build is run\nFunctions 1 2 3  assert!(1==2,\u0026#34;wasn\u0026#39;t true\u0026#34;);//it will print wasn\u0026#39;t true when test fails assert_eq!(6,6);assert_ne!(6,5);  Run test 1  cargo test   Run tests in parallel or consecutively 1  cargo test -- --test-threads=\u0026lt;numbers\u0026gt;   Change output capture behavior, show logs 1  cargo test -- --nocapture   Run single or multiple tests 1  cargo test \u0026lt;function-name|pattern\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  pubfn add_one(num: i64)-\u0026gt; i64 {num+1}pubfn add_two(num: i64)-\u0026gt; i64 {num+2}#[cfg(test)]mod tests{usesuper::*;#[test]fn add_one_test(){assert_eq!!(4,add_one(3));}#[test]fn add_two_test(){assert_eq!(6,add_two(4));}}  Example\n1 2 3 4  //will run only one test cargo test add_one_test //will run all tests starting with add_ cargo test add_   Test function that should panic use #[should_panic] attribute\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  pubfn i_panic(){panic!(\u0026#34;omg!\u0026#34;);}#[cfg(test)]mod test{usesuper::*;#[test]#[should_panic]fn should_panic(){i_panic();}}//The above test will pass   Ignore a test Use #[ignore] attribute\nIntegration tests Make a directory called tests at the root level of the project. Assume you have this code in the lib.rs file in the project adder\n1 2 3 4 5 6 7  /* |-adder/src |--lib.rs */pubadd_two(num: i64)-\u0026gt; i64{num+2}  tests/integration_test.rs\n1 2 3 4 5 6  externcrateadder;#[test]fn add_two_test(){assert_eq!(6,adder::add_two(4));}  We don\u0026rsquo;t need to use #[cfg(test)] here. When running cargo test, it will run both unit and integration tests. You can also run only tests from a particular integration test file. In the above example, if you want to run tests from integration_test.ts file\n1  cargotest--testintegration_test.rs  ","permalink":"https://darve.sh/posts/rust/tests/","summary":"The #[cfg(test)] annotation tells Rust to run the function only when cargo test is run and not when cargo build is run\nFunctions 1 2 3  assert!(1==2,\u0026#34;wasn\u0026#39;t true\u0026#34;);//it will print wasn\u0026#39;t true when test fails assert_eq!(6,6);assert_ne!(6,5);  Run test 1  cargo test   Run tests in parallel or consecutively 1  cargo test -- --test-threads=\u0026lt;numbers\u0026gt;   Change output capture behavior, show logs 1  cargo test -- --nocapture   Run single or multiple tests 1  cargo test \u0026lt;function-name|pattern\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  pubfn add_one(num: i64)-\u0026gt; i64 {num+1}pubfn add_two(num: i64)-\u0026gt; i64 {num+2}#[cfg(test)]mod tests{usesuper::*;#[test]fn add_one_test(){assert_eq!","title":"Rust: Writing tests"}]